#! /usr/bin/env racket
#lang racket

(require json)

(struct secret-file (source-path
                     name
                     size
                     owner
                     group
                     mode)
  #:transparent)

(define raw-file-contract
  (and/c
     (curryr dict-has-key? 'source)
     (hash/dc
      [k1 (or/c 'source
                'name
                'owner
                'group
                'mode)]
      [v1 (k1)
          (case k1
            [(source) path-string?]
            [(name) path-string?]
            [(owner) string?]
            [(group) string?]
            [(mode) string?])])))

(define/contract (make-file file-config)
  (-> (or/c string? raw-file-contract) secret-file?)
  (let* ([file-config (if (string? file-config) (hash 'source file-config) file-config)]
         [source-path (string->path (dict-ref file-config 'source))]
         [fs (file-size source-path)]
         [name (dict-ref file-config 'name (file-name-from-path source-path))]
         [owner (dict-ref file-config 'owner "root")]
         [group (dict-ref file-config 'group "root")]
         [mode (dict-ref file-config 'mode "400")])
    (secret-file source-path name fs owner group mode)))

(define (raw-config? obj)

  (define required-keys (seteq 'host 'files))
  (define optional-keys (seteq 'basedir))
  (define permitted-keys
    (set-union required-keys optional-keys))
  
  (and (hash? obj)
       (hash-has-key? obj 'host)
       (hash-has-key? obj 'files)
       (empty? (filter (lambda (k) (not (set-member? permitted-keys k))) (hash-keys obj)))))

(define/contract (dict-has-keys? d keys)
  (-> dict? (or/c generic-set?) boolean?)

  (stream-empty? (stream-filter
                  (negate (curry dict-has-key? d))
                  (set->stream keys))))

(define raw-file-list-contract
  (listof
   (or/c
    path-string?
    raw-file-contract)))

(define raw-config-contract
  (and/c (curryr dict-has-keys? '(host files))
         (hash/dc [k (or/c 'host 'files 'basedir)]
                  [v (k) (case k
                           [(host) string?]
                           [(basedir) string?]
                           [(files) raw-file-list-contract])])))

(define/contract (simple-keyword-apply proc kwargs args)
  (-> procedure? (hash/c (or/c symbol? string? keyword?) any/c) (listof any/c) any/c)

  (define (ensure-keyword x)
    (if (keyword? x)
        x
        (if (symbol? x)
            (string->keyword (symbol->string x))
            (string->keyword x))))

  (define (convert-key-to-keyword pair)
    (let ((key (ensure-keyword (car pair)))
          (value (cdr pair)))
      (cons key value)))

  (define (split-pair pair lists)
    ""
    (let* ([keys (car lists)]
           [values (cdr lists)]
          (new-keys (cons (car pair) keys))
          (new-values (cons (cdr pair) values)))
      (cons new-keys new-values)))

  (let* ((sorted-list (sort
                       (sequence->list
                        (sequence-map convert-key-to-keyword
                                      (in-dict-pairs kwargs)))
                       keyword<?
                       #:key car))
         (seperate-lists (foldr split-pair '(() . ()) sorted-list))
         (keywords (car seperate-lists))
         (values (cdr seperate-lists)))
    (keyword-apply proc keywords values args)))

(define (read-loop input-port)
  (let ([line (read-line input-port)])
    (if (eof-object? line)
      (close-input-port input-port)
      (begin
        (printf "~a\n" line)
        (read-loop input-port)))))

(define receive-script #<<EOF
#!/usr/bin/env bash
set -euo pipefail
rm "$0"
echo "!*data" >&2

read basedir
if test -d "$basedir"; then
    rm -rf "$basedir"
fi
mkdir -p "$basedir"
chown root:root "$basedir"
chmod 755 "$basedir"

while read name; do
    fullpath="$basedir/$name"
    read size
    head --bytes="$size" - > "$fullpath"
    read owner
    read group
    read mode
    chown "$owner":"$group" "$fullpath"
    chmod "$mode" "$fullpath"
done
EOF
  )

(define (script-as-base64)
  (with-input-from-string receive-script
    (lambda ()
      (with-output-to-string
        (lambda ()
          (system "base64 -w 0"))))))

(define transfer-script
  (format #<<EOF
set -euo pipefail
script=~s
scriptfile=$(mktemp)
echo $script | base64 --decode > "$scriptfile"
exec env LC_ALL=C \
sudo -S bash "$scriptfile"
EOF
          (script-as-base64)))

(define/contract (deploy-secrets raw-config)
  (-> raw-config-contract void?)

  (define (handle-stderr stderr phase-channel)
    (define p (current-error-port))
    
    (let loop ([displayed ""]
               [last-char #f]
               [char (read-char stderr)])
      (match (list displayed last-char char)
        [(list _ (? char? _) (? eof-object? _))
         (display last-char p)
         (close-input-port stderr)]

        [(list _ _ (? eof-object? _)) (close-input-port stderr)]

        [(list "" #\! #\*)
         (match (read-line stderr)
           ["data" (channel-put phase-channel 'data)
                   (copy-port stderr (current-error-port))
                   (close-input-port stderr)]
           [(? eof-object? _) (display last-char p)
                              (display char p)
                              (close-input-port stderr)]

           [line (display last-char p)
                 (display char p)
                 (displayln line p)
                 (loop "" #f (read-char stderr))])]
        
        [(list (pregexp #px"^\\[sudo\\] password for \\S*") #\: #\space)
         (display last-char p)
         (display char p)
         (channel-put phase-channel 'password)
         (loop "" #f (read-char stderr))]

        [(list _ #f _) (loop "" char (read-char stderr))]

        [(list _ #\newline _) (display last-char p)
                              (loop "" char (read-char stderr))]
        
        [(list _ _ _) (display last-char p)
                      (loop (string-append displayed (string last-char))
                            char (read-char stderr))])))

    (define (read-password)
      (system "stty -echo")
      (let ([line (read-line)])
        (system "stty echo")
        line))
     
  (define (handle-stdin stdin phase-channel basedir files)

    (define (send-data)
      (displayln basedir stdin)
      (let send-files ([files files])
        (match files
          [(list-rest (and (struct secret-file _) f) rest)
           (printf "Transfer ~a â€¦\n" (secret-file-name f))
           (displayln (secret-file-name f) stdin)
           (displayln (secret-file-size f) stdin)
           (call-with-input-file (secret-file-source-path f)
             (curryr copy-port stdin))
           (displayln (secret-file-owner f) stdin)
           (displayln (secret-file-group f) stdin)
           (displayln (secret-file-mode f) stdin)
           (send-files rest)]
          [(list) (void)])))

    (let loop ()
      (match (channel-get phase-channel)
        ['password (displayln (read-password) stdin)
                   (displayln "" (current-error-port))
                   (flush-output stdin)
                   (loop)]
        ['data (begin
                 (send-data)
                 (close-output-port stdin))])))
  
  (let* ([basedir (dict-ref raw-config 'basedir "/var/lib/secrets")]
         [files (map make-file (dict-ref raw-config 'files))]
         [host (dict-ref raw-config 'host)])
    (let-values ([(sp _ stdin stderr) (subprocess
                                       (current-output-port) #f #f
                                       (find-executable-path "ssh")
                                       host
                                       (format
                                        "bash -c '~a'"
                                        (string-replace transfer-script
                                                        "'" "\'")))])
      (let* ([phase-channel (make-channel)]
             [stderr-thread (thread
                             (lambda ()
                               (handle-stderr stderr phase-channel)))]
             [stdin-thread (thread
                            (lambda ()
                              (handle-stdin stdin phase-channel basedir files)))])
        
        (thread-wait stderr-thread)
        (thread-wait stdin-thread))))
  
  (void))

(let* ([config (call-with-input-file "config.json" read-json)])
  (deploy-secrets config)
  (displayln "Done."))